## 模块实用

#### 1. argparse

###### 1.1 介绍

argparse是python用于解析命令行参数和选项的标准模块，用于代替已经过时的optparse模块。argparse模块的作用是用于解析命令行参数。**通俗的讲就是控制命令行参数的模块，作用使命令的参数可读性强，获取参数值也更加方便。**



###### 1.2 实用步骤

我们常常可以把argparse的使用简化成下面四个步骤

```
我们常常可以把argparse的使用简化成下面四个步骤

1：import argparse

2：parser = argparse.ArgumentParser()

3：parser.add_argument()

4：parser.parse_args()
```

> **上面四个步骤解释如下：首先导入该模块；然后创建一个解析对象；然后向该对象中添加你要关注的命令行参数和选项，每一个add_argument方法对应一个你要关注的参数或选项；最后调用parse_args()方法进行解析；解析成功之后即可使用。**



###### 1.3 例子

参考文档:  https://zhuanlan.zhihu.com/p/56922793



- 打印帮助信息：

```python
import argparse
parser = argparse.ArgumentParser(description='you should add those parameter')
parser.add_argument('--addresses', type=str, help='The path of address')
args = parser.parse_args()
print(args.addresses)
```

当调用parser.print_help()或者运行程序时由于参数不正确(此时python解释器其实也是调用了pring_help()方法)时，会打印这些描述信息，一般只需要传递description参数。



执行```python3 argparse-test.py -h```输出:

![argparse](D:\github\python_action\pics\argparse.jpg)





#### 2.  sys.argv[]

一个与外部命令的桥梁



```python
import sys


print(sys.argv)       #命令的全部参数list : ['argv-test.py', '11', '22']

print(sys.argv[0])    #程序本身文件名: argv-test.py 
print(sys.argv[1])    #命令的第一个参数: 11
print(sys.argv[1:])    #命令的第一个参数: ['11','22']
```

> ```$ python3 argv-test.py 11 22```



----------------------------------------------------------------------------

#### action 1  2：优雅的配置docker stack的变量

[envsubst.py](./envsubst.py)



docker  stack不支持基于文件的环境变量(支持容器的env_file选项)，当我们想在资源文件stack file使用${变量名}的时候，比如通过文件定义镜像的版本号，我们通过下面的脚本实现：

“使用source会引入额外的复杂度，当多个项目同时更新时，甚至引发错乱，不方便管理”



```python
import argparse
import logging
import os
import sys
from typing import Dict, Iterable


class EnvironmentContext:
    _args: Dict[str, str]

    def __init__(self, env_ignore: bool):
        if env_ignore:
            self._args = {}
        else:
            self._args = os.environ.copy()

    def update(self, args: Dict[str, str]):
        self._args.update(args)

    def transform(self, input: str) -> str:
        for k, v in self._args.items():
            # ${key} = value
            k2 = '${' + k + '}'
            input = input.replace(k2, v, -1)
        return input


def _parse_env_args(lines: Iterable[str]) -> Dict[str, str]:
    dict = {}
    for line in lines:
        arr = line.split('=', 1)
        assert len(arr) == 2, 'Arg "{}" invalid'.format(line)
        dict[arr[0]] = arr[1]
    return dict


def _parse_env_file(env_file: str) -> Dict[str, str]:
    dict = {}
    with open(env_file) as f:
        for num, line in enumerate(f):
            if line and not line.startswith('#'):
                arr = line.split('=', 1)
                assert len(arr) == 2, 'Arg "{}" invalid'.format(line)
                dict[arr[0]] = arr[1].strip().strip('"')
    return dict


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--env', dest='env', type=str, nargs='*', required=False)
    parser.add_argument('--env-file', dest='env_file', action='store', required=False)
    parser.add_argument('--env-ignore', dest='env_ignore', help='ignore environment variables', action='store_true', required=False)
    parser.add_argument('-f', '--file', dest='file', action='store', required=False)
    parser.add_argument('-i', '--input', dest='input', action='store', required=False)

    if len(sys.argv) <= 2:
        parser.print_help()
    else:
        argv = parser.parse_args()
        context = EnvironmentContext(argv.env_ignore)
        if argv.env_file:
            env_args = _parse_env_file(argv.env_file)
            context.update(env_args)
        if argv.env:
            env_args = _parse_env_args(argv.env)
            context.update(env_args)

        input = argv.input
        if argv.file:
            with open(argv.file) as f:
                input = f.read()
        output = context.transform(input)
        print(output)

        output_file='output.yaml'
        with open(output_file,'w+',encoding='utf-8') as f:
          f.write(output)
```



1. **使用行内键值对**

```bash
$ python3 envsubst.py --env user=root password=123456 -i '${HOSTNAME} ${user}:${password}'
localhost.localdomain root:123456
```

2. **忽略环境变量**

```bash
$ python3 envsubst.py --env-ignore --env user=root password=123456 -i '${OS} ${user}:${password}'
${OS} root:123456
```

3. **使用基于文件的环境变量**

```bash
[jinbo@localhost ~]$ cat 1.env 
user=username
password=123456
[jinbo@localhost ~]$ python3 envsubst.py --env-file 1.env -i '${user}:${password}'
username:123456
```

4. **使用文本内容作为输入参数**

```bash
[jinbo@localhost ~]$ cat 1.yaml 
${HOSTNAME} ${user}:${password}
${HOSTNAME}
[jinbo@localhost ~]$ 
[jinbo@localhost ~]$ python3 envsubst.py --env-file 1.env -f 1.yaml 
localhost.localdomain username:123456
localhost.localdomain

[jinbo@localhost ~]$ cat output.yaml 
localhost.localdomain username:123456
localhost.localdomain
```

> 同时从当前系统环境变量和文件中获取



参考文档:   https://www.cnblogs.com/leoninew/p/13516223.html

___





